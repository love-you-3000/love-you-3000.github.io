<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT6.830-Lab-2 | Jiang's blog</title><meta name="author" content="Jiang"><meta name="copyright" content="Jiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MIT6.830 Lab2实现">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.830-Lab-2">
<meta property="og:url" content="https://jiangblog.top/2023/07/19/MIT6-830-lab2/index.html">
<meta property="og:site_name" content="Jiang&#39;s blog">
<meta property="og:description" content="MIT6.830 Lab2实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiangblog.top/img/lab2.png">
<meta property="article:published_time" content="2023-07-19T02:29:23.000Z">
<meta property="article:modified_time" content="2023-07-19T02:29:23.000Z">
<meta property="article:author" content="Jiang">
<meta property="article:tag" content="MIT6.830">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiangblog.top/img/lab2.png"><link rel="shortcut icon" href="/img/hacker.png"><link rel="canonical" href="https://jiangblog.top/2023/07/19/MIT6-830-lab2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT6.830-Lab-2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-19 10:29:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/lab2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Jiang's blog"><img class="site-icon" src="/img/logo.png"/><span class="site-name">Jiang's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MIT6.830-Lab-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-19T02:29:23.000Z" title="发表于 2023-07-19 10:29:23">2023-07-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-19T02:29:23.000Z" title="更新于 2023-07-19 10:29:23">2023-07-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MIT6-830/">MIT6.830</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MIT6.830-Lab-2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lab-2"><a href="#Lab-2" class="headerlink" title="Lab-2"></a>Lab-2</h1><p>Lab2中主要通过实现一系列运算法来对表进行聚合、连接、删除、添加等操作，除此之外，还需要在<code>BufferPool</code>满了之后，添加置换策略对页面进行置换。</p>
<p>具体的本实验的内容为</p>
<blockquote>
<ul>
<li>Implement the operators <code>Filter</code> and <code>Join</code> and verify that their corresponding tests work. The Javadoc comments for these operators contain details about how they should work. We have given you implementations of <code>Project</code> and <code>OrderBy</code> which may help you understand how other operators work.</li>
<li>Implement <code>IntegerAggregator</code> and <code>StringAggregator</code>. Here, you will write the logic that actually computes an aggregate over a particular field across multiple groups in a sequence of input tuples. Use integer division for computing the average, since SimpleDB only supports integers. StringAggegator only needs to support the COUNT aggregate, since the other operations do not make sense for strings.</li>
<li>Implement the <code>Aggregate</code> operator. As with other operators, aggregates implement the <code>OpIterator</code> interface so that they can be placed in SimpleDB query plans. Note that the output of an <code>Aggregate</code> operator is an aggregate value of an entire group for each call to <code>next()</code>, and that the aggregate constructor takes the aggregation and grouping fields.</li>
<li>Implement the methods related to tuple insertion, deletion, and page eviction in <code>BufferPool</code>. You do not need to worry about transactions at this point.</li>
<li>Implement the <code>Insert</code> and <code>Delete</code> operators. Like all operators, <code>Insert</code> and <code>Delete</code> implement <code>OpIterator</code>, accepting a stream of tuples to insert or delete and outputting a single tuple with an integer field that indicates the number of tuples inserted or deleted. These operators will need to call the appropriate methods in <code>BufferPool</code> that actually modify the pages on disk. Check that the tests for inserting and deleting tuples work properly.</li>
</ul>
</blockquote>
<h2 id="exercise-1"><a href="#exercise-1" class="headerlink" title="exercise-1"></a>exercise-1</h2><p>实验1主要实现4个类：</p>
<ul>
<li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Predicate.java</li>
<li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;JoinPredicate.java</li>
<li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Filter.java</li>
<li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Join.java</li>
</ul>
<p><strong>Predicate和JoinPredicate分别负责普通的断言和Join断言的操作</strong></p>
<p><img src="https://raw.githubusercontent.com/love-you-3000/picUpload/master/images/8754f5ca91a44ca28a2cc27f58c5a684.png" alt="img"></p>
<p>Predicate需要传进来待比较字段，操作码以及比较的值。</p>
<p>JoinPredicate需要传进来2个待比较字段以及操作符。</p>
<p><strong>SimpleDB整个迭代器的设计思路采用了装饰器模式实现，具体如下图所示:</strong></p>
<p><img src="https://raw.githubusercontent.com/love-you-3000/picUpload/master/images/3ee92f759d2c42ba8dd3d1bfced3b901.png" alt="在这里插入图片描述"></p>
<ul>
<li>Operator的实现类都是装饰器，而SeqScan是迭代器的实现，也就是被装饰的对象</li>
</ul>
<p><strong>Filter用于单值比较操作，具体流程如下:</strong></p>
<p><img src="https://raw.githubusercontent.com/love-you-3000/picUpload/master/images/bc1b5ad5c5dd4e368959a03e32622ac7.png" alt="在这里插入图片描述"></p>
<p><strong>Join用于连接条件判断，流程如下:</strong><img src="https://raw.githubusercontent.com/love-you-3000/picUpload/master/images/a2298782aceb4570ab432eb314403c10.png"></p>
<p><code>Predicate.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.execution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Field;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Predicate compares tuples to a specified Field value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Predicate</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> field;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Op op;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Field operand;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constants used for return codes in Field.compare</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Op</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        EQUALS, GREATER_THAN, LESS_THAN, LESS_THAN_OR_EQ, GREATER_THAN_OR_EQ, LIKE, NOT_EQUALS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Interface to access operations by integer value for command-line</span></span><br><span class="line"><span class="comment">         * convenience.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i a valid integer Op index</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Op <span class="title function_">getOp</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> values()[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == EQUALS)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;=&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == GREATER_THAN)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == LESS_THAN)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == LESS_THAN_OR_EQ)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&lt;=&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == GREATER_THAN_OR_EQ)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&gt;=&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == LIKE)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;LIKE&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == NOT_EQUALS)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&lt;&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;impossible to reach here&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field   field number of passed in tuples to compare against.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> op      operation to use for comparison</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> operand field value to compare passed in tuples to</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Predicate</span><span class="params">(<span class="type">int</span> field, Op op, Field operand)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">this</span>.field = field;</span><br><span class="line">        <span class="built_in">this</span>.op = op;</span><br><span class="line">        <span class="built_in">this</span>.operand = operand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the field number</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the operator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Op <span class="title function_">getOp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the operand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Field <span class="title function_">getOperand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> operand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      Compares the field number of t specified in the constructor to the</span></span><br><span class="line"><span class="comment">      operand field specified in the constructor using the operator specific in</span></span><br><span class="line"><span class="comment">      the constructor. The comparison can be made through Field&#x27;s compare</span></span><br><span class="line"><span class="comment">      method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t The tuple to compare against</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the comparison is true, false otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Tuple t)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> t.getField(field).compare(op,operand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns something useful, like &quot;f = field_id op = op_string operand =</span></span><br><span class="line"><span class="comment">     * operand_string&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Predicate&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;field=&quot;</span> + field +</span><br><span class="line">                <span class="string">&quot;, op=&quot;</span> + op +</span><br><span class="line">                <span class="string">&quot;, operand=&quot;</span> + operand +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JoinPredicate.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.execution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Tuple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JoinPredicate compares fields of two tuples using a predicate. JoinPredicate</span></span><br><span class="line"><span class="comment"> * is most likely used by the Join operator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinPredicate</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> field1;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> field2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Predicate.Op op;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor -- create a new predicate over two fields of two tuples.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field1</span></span><br><span class="line"><span class="comment">     *            The field index into the first tuple in the predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field2</span></span><br><span class="line"><span class="comment">     *            The field index into the second tuple in the predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> op</span></span><br><span class="line"><span class="comment">     *            The operation to apply (as defined in Predicate.Op); either</span></span><br><span class="line"><span class="comment">     *            Predicate.Op.GREATER_THAN, Predicate.Op.LESS_THAN,</span></span><br><span class="line"><span class="comment">     *            Predicate.Op.EQUAL, Predicate.Op.GREATER_THAN_OR_EQ, or</span></span><br><span class="line"><span class="comment">     *            Predicate.Op.LESS_THAN_OR_EQ</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JoinPredicate</span><span class="params">(<span class="type">int</span> field1, Predicate.Op op, <span class="type">int</span> field2)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">this</span>.field1 = field1;</span><br><span class="line">        <span class="built_in">this</span>.field2 = field2;</span><br><span class="line">        <span class="built_in">this</span>.op = op;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Apply the predicate to the two specified tuples. The comparison can be</span></span><br><span class="line"><span class="comment">     * made through Field&#x27;s compare method.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the tuples satisfy the predicate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Tuple t1, Tuple t2)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">       <span class="keyword">return</span>  t1.getField(field1).compare(op,t2.getField(field2));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getField1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> field1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getField2</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> field2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Predicate.Op <span class="title function_">getOperator</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> op;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Filter.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.execution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.common.DbException;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Tuple;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.TupleDesc;</span><br><span class="line"><span class="keyword">import</span> simpledb.transaction.TransactionAbortedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter is an operator that implements a relational select.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter</span> <span class="keyword">extends</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Predicate p;</span><br><span class="line">    <span class="keyword">private</span> OpIterator child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor accepts a predicate to apply and a child operator to read</span></span><br><span class="line"><span class="comment">     * tuples to filter from.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p     The predicate to filter tuples with</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child The child operator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Filter</span><span class="params">(Predicate p, OpIterator child)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">this</span>.p = p;</span><br><span class="line">        <span class="built_in">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Predicate <span class="title function_">getPredicate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> child.getTupleDesc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, NoSuchElementException,</span><br><span class="line">            TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="comment">// todo 不懂open</span></span><br><span class="line">        child.open();</span><br><span class="line">        <span class="built_in">super</span>.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.close();</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.rewind();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AbstractDbIterator.readNext implementation. Iterates over tuples from the</span></span><br><span class="line"><span class="comment">     * child operator, applying the predicate to them and returning those that</span></span><br><span class="line"><span class="comment">     * pass the predicate (i.e. for which the Predicate.filter() returns true.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The next tuple that passes the filter, or null if there are no</span></span><br><span class="line"><span class="comment">     * more tuples</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Predicate#filter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException,</span><br><span class="line">            TransactionAbortedException, DbException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">while</span> (child.hasNext())&#123;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">next</span> <span class="operator">=</span> child.next();</span><br><span class="line">            <span class="keyword">if</span> (p.filter(next))  <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OpIterator[] getChildren() &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpIterator</span>[]&#123;<span class="built_in">this</span>.child&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChildren</span><span class="params">(OpIterator[] children)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child = children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Join.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.execution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.common.DbException;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Tuple;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.TupleDesc;</span><br><span class="line"><span class="keyword">import</span> simpledb.transaction.TransactionAbortedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Join operator implements the relational join operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Join</span> <span class="keyword">extends</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JoinPredicate p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OpIterator child1; <span class="comment">// todo 暂时理解成需要执行join操作的两组存放Tuple的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> OpIterator child2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Tuple t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor. Accepts two children to join and the predicate to join them</span></span><br><span class="line"><span class="comment">     * on</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p      The predicate to use to join the children</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child1 Iterator for the left(outer) relation to join</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child2 Iterator for the right(inner) relation to join</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Join</span><span class="params">(JoinPredicate p, OpIterator child1, OpIterator child2)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">this</span>.p = p;</span><br><span class="line">        <span class="built_in">this</span>.child1 = child1;</span><br><span class="line">        <span class="built_in">this</span>.child2 = child2;</span><br><span class="line">        t = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JoinPredicate <span class="title function_">getJoinPredicate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the field name of join field1. Should be quantified by</span></span><br><span class="line"><span class="comment">     * alias or table name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getJoinField1Name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> child1.getTupleDesc().getFieldName(p.getField1());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the field name of join field2. Should be quantified by</span></span><br><span class="line"><span class="comment">     * alias or table name.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getJoinField2Name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> child2.getTupleDesc().getFieldName(p.getField2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> TupleDesc#merge(TupleDesc, TupleDesc) for possible</span></span><br><span class="line"><span class="comment">     * implementation logic.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> TupleDesc.merge(child1.getTupleDesc(), child2.getTupleDesc());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, NoSuchElementException,</span><br><span class="line">            TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child1.open();</span><br><span class="line">        child2.open();</span><br><span class="line">        <span class="built_in">super</span>.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child2.close();</span><br><span class="line">        child1.close();</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child1.rewind();</span><br><span class="line">        child2.rewind();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next tuple generated by the join, or null if there are no</span></span><br><span class="line"><span class="comment">     * more tuples. Logically, this is the next tuple in r1 cross r2 that</span></span><br><span class="line"><span class="comment">     * satisfies the join predicate. There are many possible implementations;</span></span><br><span class="line"><span class="comment">     * the simplest is a nested loops join.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Note that the tuples returned from this particular implementation of Join</span></span><br><span class="line"><span class="comment">     * are simply the concatenation of joining tuples from the left and right</span></span><br><span class="line"><span class="comment">     * relation. Therefore, if an equality predicate is used there will be two</span></span><br><span class="line"><span class="comment">     * copies of the join attribute in the results. (Removing such duplicate</span></span><br><span class="line"><span class="comment">     * columns can be done with an additional projection operator if needed.)</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * For example, if one tuple is &#123;1,2,3&#125; and the other tuple is &#123;1,5,6&#125;,</span></span><br><span class="line"><span class="comment">     * joined on equality of the first column, then this returns &#123;1,2,3,1,5,6&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The next matching tuple.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> JoinPredicate#filter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.child1.hasNext() || <span class="built_in">this</span>.t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.child1.hasNext() &amp;&amp; <span class="built_in">this</span>.t == <span class="literal">null</span>) &#123;</span><br><span class="line">                t = child1.next();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (child2.hasNext()) &#123;</span><br><span class="line">                <span class="type">Tuple</span> <span class="variable">t2</span> <span class="operator">=</span> child2.next();</span><br><span class="line">                <span class="keyword">if</span> (p.filter(t, t2)) &#123;</span><br><span class="line">                    <span class="type">TupleDesc</span> <span class="variable">td1</span> <span class="operator">=</span> t.getTupleDesc();</span><br><span class="line">                    <span class="type">TupleDesc</span> <span class="variable">td2</span> <span class="operator">=</span> t2.getTupleDesc();</span><br><span class="line">                    <span class="type">TupleDesc</span> <span class="variable">newTd</span> <span class="operator">=</span> TupleDesc.merge(td1, td2);</span><br><span class="line">                    <span class="type">Tuple</span> <span class="variable">newTuple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(newTd);</span><br><span class="line">                    newTuple.setRecordId(t.getRecordId());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; td1.numFields(); ++i)</span><br><span class="line">                        newTuple.setField(i, t.getField(i));</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; td2.numFields(); ++j)</span><br><span class="line">                        newTuple.setField(i + j, t2.getField(j));</span><br><span class="line">                    <span class="keyword">if</span> (!child2.hasNext()) &#123;</span><br><span class="line">                        child2.rewind();</span><br><span class="line">                        t = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> newTuple;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            child2.rewind();</span><br><span class="line">            t = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OpIterator[] getChildren() &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpIterator</span>[]&#123;child1, child2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChildren</span><span class="params">(OpIterator[] children)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child1 = children[<span class="number">0</span>];</span><br><span class="line">        child2 = children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exercise-2"><a href="#exercise-2" class="headerlink" title="exercise-2"></a>exercise-2</h2><p>实验2要实现对字段的聚合和分组聚合，聚合操作主要有<code>SUM</code>,<code>AVG</code>,<code>MAX</code>,<code>MIN</code>,<code>COUNT</code>等，分组聚合需要通过<code>group by</code>。</p>
<p>主要实现3个类：</p>
<ul>
<li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;IntegerAggregator.java</li>
<li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;StringAggregator.java</li>
<li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Aggregate.java</li>
</ul>
<p>其中，<code>IntegerAggregator</code>和<code>StringAggregator</code>是对某个tuple的某个字段进行聚合，而<code>Aggregate</code>会传入整个<code>tuple</code>的迭代器，然后依次进行聚合。</p>
<p>(注意，本实验中，<code>StringAggregator</code>只支持<code>count</code>聚合)</p>
<p><code>IntegerAggregator.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.execution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.common.DbException;</span><br><span class="line"><span class="keyword">import</span> simpledb.common.Type;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Field;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.IntField;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Tuple;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.TupleDesc;</span><br><span class="line"><span class="keyword">import</span> simpledb.transaction.TransactionAbortedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Knows how to compute some aggregate over a set of IntFields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerAggregator</span> <span class="keyword">implements</span> <span class="title class_">Aggregator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Field</span> <span class="variable">NO_GROUP</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntField</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo 这块理解了好久，翻译成sql就是 select gbfield, what(afield) from table group by gbfield;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> gbfield; <span class="comment">// 用于分组的字段索引，从0开始，如果是-1就是不分组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Type gbfieldtype; <span class="comment">// 分组字段的类型，如果没有分组字段，则为null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> afield; <span class="comment">// 聚合哪个字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Op what; <span class="comment">// 执行那种聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TupleDesc tupleDesc;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Field, Tuple&gt; aggregate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于非分组情况下的聚合操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counts;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> summary;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于分组情况下的聚合操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Field, Integer&gt; countsMap;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Field, Integer&gt; sumMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Aggregate constructor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbfield     the 0-based index of the group-by field in the tuple, or</span></span><br><span class="line"><span class="comment">     *                    NO_GROUPING if there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbfieldtype the type of the group by field (e.g., Type.INT_TYPE), or null</span></span><br><span class="line"><span class="comment">     *                    if there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> afield      the 0-based index of the aggregate field in the tuple</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> what        the aggregation operator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntegerAggregator</span><span class="params">(<span class="type">int</span> gbfield, Type gbfieldtype, <span class="type">int</span> afield, Op what)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="comment">//分组字段</span></span><br><span class="line">        <span class="built_in">this</span>.gbfield = gbfield;</span><br><span class="line">        <span class="comment">//分组字段类型</span></span><br><span class="line">        <span class="built_in">this</span>.gbfieldtype = gbfieldtype;</span><br><span class="line">        <span class="comment">//聚合得到的结果,在聚合返回结果行中的字段下标</span></span><br><span class="line">        <span class="built_in">this</span>.afield = afield;</span><br><span class="line">        <span class="comment">//进行什么样的聚合操作</span></span><br><span class="line">        <span class="built_in">this</span>.what = what;</span><br><span class="line">        <span class="comment">//存放聚合结果</span></span><br><span class="line">        <span class="built_in">this</span>.aggregate = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 非分组聚合</span></span><br><span class="line">        <span class="keyword">if</span> (gbfield == NO_GROUPING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.tupleDesc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aggregateValue&quot;</span>&#125;);</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(tupleDesc);</span><br><span class="line">            <span class="comment">//占位符</span></span><br><span class="line">            <span class="built_in">this</span>.aggregate.put(NO_GROUP, tuple);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 分组聚合,那么返回的聚合结果行由分组字段和该分组字段的聚合结果值组成</span></span><br><span class="line">            <span class="built_in">this</span>.tupleDesc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;gbfieldtype, Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;groupValue&quot;</span>, <span class="string">&quot;aggregateValue&quot;</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果聚合操作是AVG,那么需要初始化count和summary变量,用于存放AVG聚合中间计算状态</span></span><br><span class="line">        <span class="keyword">if</span> (gbfield == NO_GROUPING &amp;&amp; what.equals(Op.AVG)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.counts = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.summary = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gbfield != NO_GROUPING &amp;&amp; what.equals(Op.AVG)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.countsMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.sumMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge a new tuple into the aggregate, grouping as indicated in the</span></span><br><span class="line"><span class="comment">     * constructor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tup the Tuple containing an aggregate field and a group-by field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeTupleIntoGroup</span><span class="params">(Tuple tup)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="comment">// 从传递给聚合器的行记录中取出聚合字段的值</span></span><br><span class="line">        <span class="type">IntField</span> <span class="variable">operationField</span> <span class="operator">=</span> (IntField) tup.getField(<span class="built_in">this</span>.afield);</span><br><span class="line">        <span class="keyword">if</span> (operationField == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 非分组聚合</span></span><br><span class="line">        <span class="keyword">if</span> (gbfield == NO_GROUPING) &#123;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> aggregate.get(NO_GROUP);</span><br><span class="line">            <span class="type">IntField</span> <span class="variable">field</span> <span class="operator">=</span> (IntField) tuple.getField(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 说明是进行聚合的第一行记录</span></span><br><span class="line">            <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果聚合是统计个数操作</span></span><br><span class="line">                <span class="keyword">if</span> (what.equals(Op.COUNT)) &#123;</span><br><span class="line">                    tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(<span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (what.equals(Op.AVG)) &#123;</span><br><span class="line">                    <span class="comment">// 如果聚合是求平均值操作</span></span><br><span class="line">                    <span class="comment">// 统计参与聚合的记录个数</span></span><br><span class="line">                    counts++;</span><br><span class="line">                    <span class="comment">// 累加每个值</span></span><br><span class="line">                    summary = operationField.getValue();</span><br><span class="line">                    <span class="comment">// 如果参与聚合的行只存在一个,那么平均值就是当前行的值</span></span><br><span class="line">                    tuple.setField(<span class="number">0</span>, operationField);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他的情况: MIN,MAX,SUM在参与聚合的行只存在一个时,聚合结果就是当前行的值</span></span><br><span class="line">                    <span class="comment">// 所以这里可以统一处理</span></span><br><span class="line">                    tuple.setField(<span class="number">0</span>, operationField);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是哪种类型的聚合</span></span><br><span class="line">            <span class="comment">// 非第一行记录</span></span><br><span class="line">            <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MIN:</span><br><span class="line">                    <span class="keyword">if</span> (operationField.compare(Predicate.Op.LESS_THAN, field)) &#123;</span><br><span class="line">                        tuple.setField(<span class="number">0</span>, operationField);</span><br><span class="line">                        aggregate.put(NO_GROUP, tuple);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">case</span> MAX:</span><br><span class="line">                    <span class="keyword">if</span> (operationField.compare(Predicate.Op.GREATER_THAN, field)) &#123;</span><br><span class="line">                        tuple.setField(<span class="number">0</span>, operationField);</span><br><span class="line">                        aggregate.put(NO_GROUP, tuple);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">case</span> COUNT:</span><br><span class="line">                    tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(field.getValue() + <span class="number">1</span>));</span><br><span class="line">                    aggregate.put(NO_GROUP, tuple);</span><br><span class="line">                <span class="keyword">case</span> SUM:</span><br><span class="line">                    tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(field.getValue() + operationField.getValue()));</span><br><span class="line">                    aggregate.put(NO_GROUP, tuple);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">case</span> AVG:</span><br><span class="line">                    <span class="comment">// 求平均值,每次往整数聚合器塞入一条记录时,都会将记录数和总和累加</span></span><br><span class="line">                    counts++;</span><br><span class="line">                    summary += operationField.getValue();</span><br><span class="line">                    <span class="type">IntField</span> <span class="variable">avg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntField</span>(summary / counts);</span><br><span class="line">                    tuple.setField(<span class="number">0</span>, avg);</span><br><span class="line">                    aggregate.put(NO_GROUP, tuple);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分组聚合</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取分组的字段</span></span><br><span class="line">            <span class="type">Field</span> <span class="variable">groupByField</span> <span class="operator">=</span> tup.getField(gbfield);</span><br><span class="line">            <span class="comment">// 如果聚合结果中还不包括当前字段值,说明当前字段是第一次出现</span></span><br><span class="line">            <span class="comment">// 例如: group by age --&gt; &lt;age=18,count=20&gt; ,如果此次获取的age=20,那么就是第一次出现的分组值</span></span><br><span class="line">            <span class="keyword">if</span> (!aggregate.containsKey(groupByField)) &#123;</span><br><span class="line">                <span class="type">Tuple</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(<span class="built_in">this</span>.tupleDesc);</span><br><span class="line">                value.setField(<span class="number">0</span>, groupByField);</span><br><span class="line">                <span class="keyword">if</span> (what.equals(Op.COUNT)) &#123;</span><br><span class="line">                    value.setField(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(<span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (what.equals(Op.AVG)) &#123;</span><br><span class="line">                    countsMap.put(groupByField, countsMap.getOrDefault(groupByField, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    sumMap.put(groupByField, sumMap.getOrDefault(groupByField, <span class="number">0</span>) + operationField.getValue());</span><br><span class="line">                    value.setField(<span class="number">1</span>, operationField);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 其他的情况: MIN,MAX,SUM在参与聚合的行只存在一个时,结果假设当前行的值</span></span><br><span class="line">                    <span class="comment">// 所以这里可以统一处理</span></span><br><span class="line">                    value.setField(<span class="number">1</span>, operationField);</span><br><span class="line">                &#125;</span><br><span class="line">                aggregate.put(groupByField, value);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前字段不是第一次出现的分组值</span></span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> aggregate.get(groupByField);</span><br><span class="line">            <span class="comment">// 获取本阶段的聚合结果</span></span><br><span class="line">            <span class="type">IntField</span> <span class="variable">field</span> <span class="operator">=</span> (IntField) tuple.getField(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MIN:</span><br><span class="line">                    <span class="keyword">if</span> (operationField.compare(Predicate.Op.LESS_THAN, field)) &#123;</span><br><span class="line">                        tuple.setField(<span class="number">1</span>, operationField);</span><br><span class="line">                        aggregate.put(groupByField, tuple);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">case</span> MAX:</span><br><span class="line">                    <span class="keyword">if</span> (operationField.compare(Predicate.Op.GREATER_THAN, field)) &#123;</span><br><span class="line">                        tuple.setField(<span class="number">1</span>, operationField);</span><br><span class="line">                        aggregate.put(groupByField, tuple);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">case</span> COUNT:</span><br><span class="line">                    <span class="type">IntField</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntField</span>(field.getValue() + <span class="number">1</span>);</span><br><span class="line">                    tuple.setField(<span class="number">1</span>, count);</span><br><span class="line">                    aggregate.put(groupByField, tuple);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">case</span> SUM:</span><br><span class="line">                    <span class="type">IntField</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntField</span>(field.getValue() + operationField.getValue());</span><br><span class="line">                    tuple.setField(<span class="number">1</span>, sum);</span><br><span class="line">                    aggregate.put(groupByField, tuple);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">case</span> AVG:</span><br><span class="line">                    countsMap.put(groupByField, countsMap.getOrDefault(groupByField, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    sumMap.put(groupByField, sumMap.getOrDefault(groupByField, <span class="number">0</span>) + operationField.getValue());</span><br><span class="line">                    <span class="type">IntField</span> <span class="variable">avg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntField</span>(sumMap.get(groupByField) / countsMap.get(groupByField));</span><br><span class="line">                    tuple.setField(<span class="number">1</span>, avg);</span><br><span class="line">                    aggregate.put(groupByField, tuple);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a OpIterator over group aggregate results.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a OpIterator whose tuples are the pair (groupVal, aggregateVal)</span></span><br><span class="line"><span class="comment">     * if using group, or a single (aggregateVal) if no grouping. The</span></span><br><span class="line"><span class="comment">     * aggregateVal is determined by the type of aggregate specified in</span></span><br><span class="line"><span class="comment">     * the constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OpIterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IntOpIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntOpIterator</span> <span class="keyword">implements</span> <span class="title class_">OpIterator</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Iterator&lt;Tuple&gt; iterator;</span><br><span class="line">        <span class="keyword">private</span> IntegerAggregator aggregator;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IntOpIterator</span><span class="params">(IntegerAggregator aggregator)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.aggregator = aggregator;</span><br><span class="line">            <span class="built_in">this</span>.iterator = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">            <span class="built_in">this</span>.iterator = aggregator.aggregate.values().iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">            <span class="keyword">return</span> iterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Tuple <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException, NoSuchElementException &#123;</span><br><span class="line">            <span class="keyword">return</span> iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">            iterator = aggregator.aggregate.values().iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> aggregator.tupleDesc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">            iterator = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>StringAggregator.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.execution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.common.DbException;</span><br><span class="line"><span class="keyword">import</span> simpledb.common.Type;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Field;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.IntField;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Tuple;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.TupleDesc;</span><br><span class="line"><span class="keyword">import</span> simpledb.transaction.TransactionAbortedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Knows how to compute some aggregate over a set of StringFields.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringAggregator</span> <span class="keyword">implements</span> <span class="title class_">Aggregator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IntField</span> <span class="variable">NO_GROUP</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntField</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> gbfield;</span><br><span class="line">    <span class="keyword">private</span> Type gbfieldtype;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于聚合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> afield;</span><br><span class="line">    <span class="keyword">private</span> Op what;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放结果-- 分组聚合返回的是多组键值对,分别代表分组字段不同值对应的聚合结果</span></span><br><span class="line"><span class="comment">     * 非分组聚合只会返回一个聚合结果,这里为了统一化处理,采用NO_GROUP做标记,进行区分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Field, Tuple&gt; tupleMap;</span><br><span class="line">    <span class="keyword">private</span> TupleDesc desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Aggregate constructor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbfield     the 0-based index of the group-by field in the tuple, or NO_GROUPING if there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gbfieldtype the type of the group by field (e.g., Type.INT_TYPE), or null if there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> afield      the 0-based index of the aggregate field in the tuple</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> what        aggregation operator to use -- only supports COUNT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if what != COUNT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringAggregator</span><span class="params">(<span class="type">int</span> gbfield, Type gbfieldtype, <span class="type">int</span> afield, Op what)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="comment">//字符串只支持COUNT聚合操作</span></span><br><span class="line">        <span class="keyword">if</span> (!what.equals(Op.COUNT)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.gbfield = gbfield;</span><br><span class="line">        <span class="built_in">this</span>.gbfieldtype = gbfieldtype;</span><br><span class="line">        <span class="built_in">this</span>.afield = afield;</span><br><span class="line">        <span class="built_in">this</span>.what = what;</span><br><span class="line">        <span class="built_in">this</span>.tupleMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//非分组聚合返回的结果采用占位符进行统一适配</span></span><br><span class="line">        <span class="keyword">if</span> (gbfield == NO_GROUPING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.desc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aggregateValue&quot;</span>&#125;);</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(desc);</span><br><span class="line">            tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="built_in">this</span>.tupleMap.put(NO_GROUP, tuple);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//分组聚合返回结果Schema由两个字段组成: 分组字段和聚合结果</span></span><br><span class="line">            <span class="built_in">this</span>.desc = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;gbfieldtype, Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;groupValue&quot;</span>, <span class="string">&quot;aggregateValue&quot;</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge a new tuple into the aggregate, grouping as indicated in the constructor</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tup the Tuple containing an aggregate field and a group-by field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeTupleIntoGroup</span><span class="params">(Tuple tup)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.gbfield == NO_GROUPING) &#123;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> <span class="built_in">this</span>.tupleMap.get(NO_GROUP);</span><br><span class="line">            <span class="type">IntField</span> <span class="variable">field</span> <span class="operator">=</span> (IntField) tuple.getField(<span class="number">0</span>);</span><br><span class="line">            tuple.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(field.getValue() + <span class="number">1</span>));</span><br><span class="line">            tupleMap.put(NO_GROUP, tuple);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> tup.getField(gbfield);</span><br><span class="line">            <span class="keyword">if</span> (!tupleMap.containsKey(field)) &#123;</span><br><span class="line">                <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tuple</span>(<span class="built_in">this</span>.desc);</span><br><span class="line">                tuple.setField(<span class="number">0</span>, field);</span><br><span class="line">                tuple.setField(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(<span class="number">1</span>));</span><br><span class="line">                tupleMap.put(field, tuple);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">Tuple</span> <span class="variable">tuple</span> <span class="operator">=</span> tupleMap.get(field);</span><br><span class="line">                <span class="type">IntField</span> <span class="variable">intField</span> <span class="operator">=</span> (IntField) tuple.getField(<span class="number">1</span>);</span><br><span class="line">                tuple.setField(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(intField.getValue() + <span class="number">1</span>));</span><br><span class="line">                tupleMap.put(field, tuple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a OpIterator over group aggregate results.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a OpIterator whose tuples are the pair (groupVal,</span></span><br><span class="line"><span class="comment">     * aggregateVal) if using group, or a single (aggregateVal) if no</span></span><br><span class="line"><span class="comment">     * grouping. The aggregateVal is determined by the type of</span></span><br><span class="line"><span class="comment">     * aggregate specified in the constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> OpIterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIterator</span> <span class="keyword">implements</span> <span class="title class_">OpIterator</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> StringAggregator aggregator;</span><br><span class="line">        <span class="keyword">private</span> Iterator&lt;Tuple&gt; iterator;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">StringIterator</span><span class="params">(StringAggregator aggregator)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.aggregator = aggregator;</span><br><span class="line">            <span class="built_in">this</span>.iterator = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">            <span class="built_in">this</span>.iterator = aggregator.tupleMap.values().iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">            <span class="keyword">return</span> iterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Tuple <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException, NoSuchElementException &#123;</span><br><span class="line">            <span class="keyword">return</span> iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">            iterator = aggregator.tupleMap.values().iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> aggregator.desc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">            iterator = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Aggregate.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.execution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.common.DbException;</span><br><span class="line"><span class="keyword">import</span> simpledb.common.Type;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Tuple;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.TupleDesc;</span><br><span class="line"><span class="keyword">import</span> simpledb.transaction.TransactionAbortedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The Aggregation operator that computes an aggregate (e.g., sum, avg, max,</span></span><br><span class="line"><span class="comment"> * min). Note that we only support aggregates over a single column, grouped by a</span></span><br><span class="line"><span class="comment"> * single column.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露该类来执行sql</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Aggregate</span> <span class="keyword">extends</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OpIterator child; <span class="comment">// 用于不断提供Tuples</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> afield; <span class="comment">// 需要聚合的字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> gfield; <span class="comment">// 需要group by的列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Aggregator.Op aop; <span class="comment">// 聚合操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Aggregator aggregator; <span class="comment">// 具体的聚合运算类型</span></span><br><span class="line">    <span class="keyword">private</span> OpIterator it; <span class="comment">// // 聚合结果迭代器，存着一个个的tuple</span></span><br><span class="line">    <span class="keyword">private</span> TupleDesc td; <span class="comment">// 聚合结果的表描述</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Implementation hint: depending on the type of afield, you will want to</span></span><br><span class="line"><span class="comment">     * construct an &#123;<span class="doctag">@link</span> IntegerAggregator&#125; or &#123;<span class="doctag">@link</span> StringAggregator&#125; to help</span></span><br><span class="line"><span class="comment">     * you with your implementation of readNext().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child  The OpIterator that is feeding us tuples.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> afield The column over which we are computing an aggregate.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gfield The column over which we are grouping the result, or -1 if</span></span><br><span class="line"><span class="comment">     *               there is no grouping</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aop    The aggregation operator to use</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Aggregate</span><span class="params">(OpIterator child, <span class="type">int</span> afield, <span class="type">int</span> gfield, Aggregator.Op aop)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">this</span>.child = child;</span><br><span class="line">        <span class="built_in">this</span>.afield = afield;</span><br><span class="line">        <span class="built_in">this</span>.gfield = gfield;</span><br><span class="line">        <span class="built_in">this</span>.aop = aop;</span><br><span class="line">        <span class="comment">// 聚合类型,如果是-1,,说明不分组聚合</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">gfieldtype</span> <span class="operator">=</span> gfield == -<span class="number">1</span> ? <span class="literal">null</span> : <span class="built_in">this</span>.child.getTupleDesc().getFieldType(<span class="built_in">this</span>.gfield);</span><br><span class="line">        <span class="comment">// 选用合适的聚合器</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.child.getTupleDesc().getFieldType(<span class="built_in">this</span>.afield) == (Type.STRING_TYPE))&#123;</span><br><span class="line">            <span class="built_in">this</span>.aggregator = <span class="keyword">new</span> <span class="title class_">StringAggregator</span>(<span class="built_in">this</span>.gfield,gfieldtype,<span class="built_in">this</span>.afield,<span class="built_in">this</span>.aop);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.aggregator = <span class="keyword">new</span> <span class="title class_">IntegerAggregator</span>(<span class="built_in">this</span>.gfield,gfieldtype,<span class="built_in">this</span>.afield,<span class="built_in">this</span>.aop);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取聚合器的迭代器</span></span><br><span class="line">        <span class="built_in">this</span>.it = <span class="built_in">this</span>.aggregator.iterator();</span><br><span class="line">        <span class="comment">// 构造聚合结果的表头信息</span></span><br><span class="line">        List&lt;Type&gt; types = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 如果分组了，第一列表头是gfield</span></span><br><span class="line">        <span class="keyword">if</span> (gfieldtype != <span class="literal">null</span>) &#123;</span><br><span class="line">            types.add(gfieldtype);</span><br><span class="line">            names.add(<span class="built_in">this</span>.child.getTupleDesc().getFieldName(<span class="built_in">this</span>.gfield));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，如果上面判断分组的条件没有执行，也就是乜有分组，那么types和names列表的长度 应该是1，如果执行了就是2</span></span><br><span class="line">        types.add(<span class="built_in">this</span>.child.getTupleDesc().getFieldType(<span class="built_in">this</span>.afield));</span><br><span class="line">        names.add(<span class="built_in">this</span>.child.getTupleDesc().getFieldName(<span class="built_in">this</span>.afield));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aop.equals(Aggregator.Op.SUM_COUNT)) &#123;</span><br><span class="line">            types.add(Type.INT_TYPE);</span><br><span class="line">            names.add(<span class="string">&quot;COUNT&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.td = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(types.toArray(<span class="keyword">new</span> <span class="title class_">Type</span>[<span class="number">0</span>]), names.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> If this aggregate is accompanied by a groupby, return the groupby</span></span><br><span class="line"><span class="comment">     * field index in the &lt;b&gt;INPUT&lt;/b&gt; tuples. If not, return</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Aggregator#NO_GROUPING&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">groupField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> gfield;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> If this aggregate is accompanied by a group by, return the name</span></span><br><span class="line"><span class="comment">     * of the groupby field in the &lt;b&gt;OUTPUT&lt;/b&gt; tuples. If not, return</span></span><br><span class="line"><span class="comment">     * null;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">groupFieldName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.td.getFieldName(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the aggregate field</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">aggregateField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">this</span>.afield;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return the name of the aggregate field in the &lt;b&gt;OUTPUT&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * tuples</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">aggregateFieldName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.gfield == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.td.getFieldName(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.td.getFieldName(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> return the aggregate operator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Aggregator.Op <span class="title function_">aggregateOp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.aop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">nameOfAggregatorOp</span><span class="params">(Aggregator.Op aop)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> aop.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException, DbException,</span><br><span class="line">            TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">this</span>.child.open();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.child.hasNext())</span><br><span class="line">            <span class="built_in">this</span>.aggregator.mergeTupleIntoGroup(<span class="built_in">this</span>.child.next());</span><br><span class="line">        <span class="built_in">this</span>.it.open();</span><br><span class="line">        <span class="built_in">super</span>.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the next tuple. If there is a group by field, then the first</span></span><br><span class="line"><span class="comment">     * field is the field by which we are grouping, and the second field is the</span></span><br><span class="line"><span class="comment">     * result of computing the aggregate. If there is no group by field, then</span></span><br><span class="line"><span class="comment">     * the result tuple should contain one field representing the result of the</span></span><br><span class="line"><span class="comment">     * aggregate. Should return null if there are no more tuples.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.it.hasNext())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.it.next();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">this</span>.child.rewind();</span><br><span class="line">        <span class="built_in">this</span>.it.rewind();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the TupleDesc of this Aggregate. If there is no group by field,</span></span><br><span class="line"><span class="comment">     * this will have one field - the aggregate column. If there is a group by</span></span><br><span class="line"><span class="comment">     * field, the first field will be the group by field, and the second will be</span></span><br><span class="line"><span class="comment">     * the aggregate value column.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The name of an aggregate column should be informative. For example:</span></span><br><span class="line"><span class="comment">     * &quot;aggName(aop) (child_td.getFieldName(afield))&quot; where aop and afield are</span></span><br><span class="line"><span class="comment">     * given in the constructor, and child_td is the TupleDesc of the child</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.td;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        <span class="built_in">this</span>.child.close();</span><br><span class="line">        <span class="built_in">this</span>.it.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OpIterator[] getChildren() &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpIterator</span>[] &#123;<span class="built_in">this</span>.child&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChildren</span><span class="params">(OpIterator[] children)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.child = children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="exercise-3"><a href="#exercise-3" class="headerlink" title="exercise-3"></a>exercise-3</h2><p>实验3要实现<code>tuple</code>的插入和删除，主要实现以下类：</p>
<ul>
<li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapPage.java</li>
<li>src&#x2F;java&#x2F;simpledb&#x2F;storage&#x2F;HeapFile.java</li>
</ul>
<p><code>HeapPage.java</code></p>
<p>插入：找到第一个header中slot为0的位置插入新的tuple并更新recordID</p>
<p>删除：通过recordID找到对应的tuple并置slot为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteTuple</span><span class="params">(Tuple t)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="type">RecordId</span> <span class="variable">recordId</span> <span class="operator">=</span> t.getRecordId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">slotNum</span> <span class="operator">=</span> recordId.getTupleNumber();</span><br><span class="line">    <span class="comment">// 如果不在这一页或者这一页对应的slot为0，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (recordId.getPageId().equals(<span class="built_in">this</span>.pid) &amp;&amp; isSlotUsed(slotNum)) &#123;</span><br><span class="line">        markSlotUsed(slotNum, <span class="literal">false</span>);</span><br><span class="line">        tuples[slotNum] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;tuple is not in this page&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertTuple</span><span class="params">(Tuple t)</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">    <span class="comment">// some code goes here</span></span><br><span class="line">    <span class="comment">// not necessary for lab1</span></span><br><span class="line">    <span class="keyword">if</span>(getNumEmptySlots() == <span class="number">0</span> || !t.getTupleDesc().equals(td))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;page is full or tuple descriptor does not match&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到第一个slot为空的位置插入新的Tuple</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;numSlots;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isSlotUsed(i))&#123;</span><br><span class="line">            markSlotUsed(i,<span class="literal">true</span>);</span><br><span class="line">            t.setRecordId(<span class="keyword">new</span> <span class="title class_">RecordId</span>(pid,i));</span><br><span class="line">            tuples[i] = t;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>HeapFile.java</code></p>
<p>所有获取页的操作都要通过BufferPool的getPage方法获取，getPage可能会出发页面置换策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Page&gt; <span class="title function_">insertTuple</span><span class="params">(TransactionId tid, Tuple t)</span></span><br><span class="line">            <span class="keyword">throws</span> DbException, IOException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="comment">// not necessary for lab1</span></span><br><span class="line">        ArrayList&lt;Page&gt; pageList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numPages(); ++i) &#123;</span><br><span class="line">            <span class="comment">// took care of getting new page</span></span><br><span class="line">            <span class="type">HeapPageId</span> <span class="variable">heapPageId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(<span class="built_in">this</span>.getId(), i);</span><br><span class="line">            <span class="type">HeapPage</span> <span class="variable">page</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid,</span><br><span class="line">                    heapPageId, Permissions.READ_WRITE);</span><br><span class="line">            <span class="keyword">if</span> (page.getNumEmptySlots() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// lab4 解锁</span></span><br><span class="line">                Database.getBufferPool().unsafeReleasePage(tid, heapPageId);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            page.insertTuple(t);</span><br><span class="line">            pageList.add(page);</span><br><span class="line">            <span class="keyword">return</span> pageList;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果现有的页都没有空闲的slot，则新起一页</span></span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f, <span class="literal">true</span>));</span><br><span class="line">        <span class="type">byte</span>[] emptyData = HeapPage.createEmptyPageData();</span><br><span class="line">        bw.write(emptyData);</span><br><span class="line">        bw.close();</span><br><span class="line">        <span class="comment">// 加载进BufferPool</span></span><br><span class="line">        <span class="type">HeapPage</span> <span class="variable">p</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HeapPageId</span>(getId(), numPages() - <span class="number">1</span>), Permissions.READ_WRITE);</span><br><span class="line">        p.insertTuple(t);</span><br><span class="line">        p.markDirty(<span class="literal">true</span>, tid);</span><br><span class="line">        pageList.add(p);</span><br><span class="line">        <span class="keyword">return</span> pageList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// see DbFile.java for javadocs</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Page&gt; <span class="title function_">deleteTuple</span><span class="params">(TransactionId tid, Tuple t)</span> <span class="keyword">throws</span> DbException,</span><br><span class="line">            TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="comment">// not necessary for lab1</span></span><br><span class="line">        <span class="type">HeapPage</span> <span class="variable">page</span> <span class="operator">=</span> (HeapPage) Database.getBufferPool().getPage(tid,</span><br><span class="line">                t.getRecordId().getPageId(), Permissions.READ_WRITE);</span><br><span class="line">        page.deleteTuple(t);</span><br><span class="line">        page.markDirty(<span class="literal">true</span>, tid);</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(page);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="exercise-4"><a href="#exercise-4" class="headerlink" title="exercise-4"></a>exercise-4</h2><p>实验4实现以下两个类</p>
<ul>
<li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Insert.java</li>
<li>src&#x2F;java&#x2F;simpledb&#x2F;execution&#x2F;Delete.java</li>
</ul>
<p>这两个类对输入的tulpes迭代器中的每个tuples进行插入和删除的批量操作，而内部调用的是BufferPool的delete和insert操作，BufferPool中的这两个操作调用的是exercise-3中HeapFile中实现的方法。</p>
<p><code>Insert.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.execution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.common.Database;</span><br><span class="line"><span class="keyword">import</span> simpledb.common.DbException;</span><br><span class="line"><span class="keyword">import</span> simpledb.common.Type;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.BufferPool;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.IntField;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Tuple;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.TupleDesc;</span><br><span class="line"><span class="keyword">import</span> simpledb.transaction.TransactionAbortedException;</span><br><span class="line"><span class="keyword">import</span> simpledb.transaction.TransactionId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inserts tuples read from the child operator into the tableId specified in the</span></span><br><span class="line"><span class="comment"> * constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insert</span> <span class="keyword">extends</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TransactionId t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OpIterator child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> tableId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TupleDesc td;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Tuple insertTuple;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t       The transaction running the insert.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child   The child operator from which to read tuples to be inserted.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableId The table in which to insert tuples.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> DbException if TupleDesc of child differs from table into which we are to</span></span><br><span class="line"><span class="comment">     *                     insert.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Insert</span><span class="params">(TransactionId t, OpIterator child, <span class="type">int</span> tableId)</span></span><br><span class="line">            <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.child = child;</span><br><span class="line">        <span class="built_in">this</span>.tableId = tableId;</span><br><span class="line">        <span class="built_in">this</span>.td = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;the number of inserted tuples&quot;</span>&#125;);</span><br><span class="line">        <span class="built_in">this</span>.count = -<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.insertTuple = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.td;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.open();</span><br><span class="line">        <span class="built_in">super</span>.open();</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.close();</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        <span class="built_in">this</span>.count = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.rewind();</span><br><span class="line">        <span class="built_in">this</span>.count = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts tuples read from child into the tableId specified by the</span></span><br><span class="line"><span class="comment">     * constructor. It returns a one field tuple containing the number of</span></span><br><span class="line"><span class="comment">     * inserted records. Inserts should be passed through BufferPool. An</span></span><br><span class="line"><span class="comment">     * instances of BufferPool is available via Database.getBufferPool(). Note</span></span><br><span class="line"><span class="comment">     * that insert DOES NOT need check to see if a particular tuple is a</span></span><br><span class="line"><span class="comment">     * duplicate before inserting it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A 1-field tuple containing the number of inserted records, or</span></span><br><span class="line"><span class="comment">     * null if called more than once.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Database#getBufferPool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BufferPool#insertTuple</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (insertTuple != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// todo 多次调用返回null，也就是第一次调用的时候insertTuple一定为null，之后调用相当于重复插入了就直接返回null</span></span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">toInsertTuple</span> <span class="operator">=</span> child.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Database.getBufferPool().insertTuple(t, tableId, toInsertTuple);</span><br><span class="line">                <span class="built_in">this</span>.count++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        insertTuple = <span class="keyword">new</span> <span class="title class_">Tuple</span>(<span class="built_in">this</span>.td);</span><br><span class="line">        insertTuple.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(<span class="built_in">this</span>.count));</span><br><span class="line">        <span class="keyword">return</span> insertTuple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OpIterator[] getChildren() &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpIterator</span>[]&#123;child&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChildren</span><span class="params">(OpIterator[] children)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child = children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Delete.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.execution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.common.Database;</span><br><span class="line"><span class="keyword">import</span> simpledb.common.DbException;</span><br><span class="line"><span class="keyword">import</span> simpledb.common.Type;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.BufferPool;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.IntField;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.Tuple;</span><br><span class="line"><span class="keyword">import</span> simpledb.storage.TupleDesc;</span><br><span class="line"><span class="keyword">import</span> simpledb.transaction.TransactionAbortedException;</span><br><span class="line"><span class="keyword">import</span> simpledb.transaction.TransactionId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The delete operator. Delete reads tuples from its child operator and removes</span></span><br><span class="line"><span class="comment"> * them from the table they belong to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Delete</span> <span class="keyword">extends</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TransactionId t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OpIterator child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TupleDesc td;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> deleteCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Tuple deleteTuple;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor specifying the transaction that this delete belongs to as</span></span><br><span class="line"><span class="comment">     * well as the child to read from.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t     The transaction this delete runs in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child The child operator from which to read tuples for deletion</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Delete</span><span class="params">(TransactionId t, OpIterator child)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.child = child;</span><br><span class="line">        <span class="built_in">this</span>.td = <span class="keyword">new</span> <span class="title class_">TupleDesc</span>(<span class="keyword">new</span> <span class="title class_">Type</span>[]&#123;Type.INT_TYPE&#125;, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;the number of deleted tuples&quot;</span>&#125;);</span><br><span class="line">        <span class="built_in">this</span>.deleteCount = -<span class="number">1</span>;</span><br><span class="line">        deleteTuple = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TupleDesc <span class="title function_">getTupleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> td;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.open();</span><br><span class="line">        <span class="built_in">super</span>.open();</span><br><span class="line">        <span class="built_in">this</span>.deleteCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.close();</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        <span class="built_in">this</span>.deleteCount = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span> <span class="keyword">throws</span> DbException, TransactionAbortedException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child.rewind();</span><br><span class="line">        <span class="built_in">this</span>.deleteCount = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deletes tuples as they are read from the child operator. Deletes are</span></span><br><span class="line"><span class="comment">     * processed via the buffer pool (which can be accessed via the</span></span><br><span class="line"><span class="comment">     * Database.getBufferPool() method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A 1-field tuple containing the number of deleted records.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Database#getBufferPool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BufferPool#deleteTuple</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Tuple <span class="title function_">fetchNext</span><span class="params">()</span> <span class="keyword">throws</span> TransactionAbortedException, DbException &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">if</span> (deleteTuple != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (child.hasNext()) &#123;</span><br><span class="line">            <span class="type">Tuple</span> <span class="variable">toDeleteTuple</span> <span class="operator">=</span> child.next();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Database.getBufferPool().deleteTuple(t, toDeleteTuple);</span><br><span class="line">                <span class="built_in">this</span>.deleteCount++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        deleteTuple = <span class="keyword">new</span> <span class="title class_">Tuple</span>(td);</span><br><span class="line">        deleteTuple.setField(<span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">IntField</span>(<span class="built_in">this</span>.deleteCount));</span><br><span class="line">        <span class="keyword">return</span> deleteTuple;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> OpIterator[] getChildren() &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpIterator</span>[]&#123;child&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChildren</span><span class="params">(OpIterator[] children)</span> &#123;</span><br><span class="line">        <span class="comment">// some code goes here</span></span><br><span class="line">        child = children[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="exercise-5"><a href="#exercise-5" class="headerlink" title="exercise-5"></a>exercise-5</h2><p>实验5主要实现BufferPool的置换策略，在调用BufferPool的getPage方法时，如果页面满了就会出发置换策略，本实验使用的是LRU置换策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> simpledb.storage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> simpledb.common.DbException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: LRUCache</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: 朱江</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: LRU置换页面</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023/7/19</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUEvict</span> <span class="keyword">implements</span> <span class="title class_">EvictStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DLinkedNode head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DLinkedNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;PageId, DLinkedNode&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LRU缓存容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUEvict</span><span class="params">(<span class="type">int</span> numPages)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(numPages);</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPageId</span><span class="params">(PageId pageId, Page page)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(pageId)) &#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(pageId);</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(pageId, page);</span><br><span class="line">            map.put(pageId, node);</span><br><span class="line">            addToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;LRU SIZE = &quot;</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PageId <span class="title function_">getEvictPageId</span><span class="params">()</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> removeTail();</span><br><span class="line">        map.remove(node.getKey());</span><br><span class="line">        <span class="keyword">return</span> node.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateByPageId</span><span class="params">(PageId pageId, Page page)</span>&#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(pageId, page);</span><br><span class="line">        map.put(pageId, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> <span class="keyword">throws</span> DbException &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="keyword">while</span> (res.getValue().isDirty() != <span class="literal">null</span> &amp;&amp; res != head)</span><br><span class="line">            res = res.prev;</span><br><span class="line">        <span class="keyword">if</span> (res == head || res == tail)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">DbException</span>(<span class="string">&quot;没有合适的页存储空间或者所有页都为脏页！！&quot;</span>);</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        PageId key;</span><br><span class="line"></span><br><span class="line">        Page value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(PageId key, Page value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> PageId <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Page <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Lab-2主要是对数据的操作，重点体会类之间的关系和数据结构，本实验中的结构大体为一个对tuple操作的类，然后通过把这个类传递给一个操作的类，该操作的类包含所有待操作的tuples，通过迭代器返回所有操作的结果。</p>
<p>主要用到了<strong>装饰器模式</strong>，这里再说明一次，认真体会</p>
<p><strong>SimpleDB整个迭代器的设计思路采用了装饰器模式实现，具体如下图所示:</strong></p>
<p><img src="https://raw.githubusercontent.com/love-you-3000/picUpload/master/images/3ee92f759d2c42ba8dd3d1bfced3b901.png" alt="在这里插入图片描述"></p>
<ul>
<li>Operator的实现类都是装饰器，而SeqScan是迭代器的实现，也就是被装饰的对象。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>MIT6.830-Lab-2</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://jiangblog.top/2023/07/19/MIT6-830-lab2/">https://jiangblog.top/2023/07/19/MIT6-830-lab2/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Jiang</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-07-19</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-07-19</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MIT6-830/">MIT6.830</a></div><div class="post_share"><div class="social-share" data-image="/img/lab2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/24/MIT6-830-lab6/" title="lab6"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">lab6</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/15/MIT6-830-lab1/" title="MIT6.830-Lab-1"><img class="cover" src="/img/lab1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MIT6.830-Lab-1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/15/MIT6-830-lab1/" title="MIT6.830-Lab-1"><img class="cover" src="/img/lab1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-15</div><div class="title">MIT6.830-Lab-1</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jiang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/love-you-3000"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/love-you-3000" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:18834198033@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客^_^,本站评论采用Giscus, 发表评论请先登录github</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab-2"><span class="toc-number">1.</span> <span class="toc-text">Lab-2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#exercise-1"><span class="toc-number">1.1.</span> <span class="toc-text">exercise-1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exercise-2"><span class="toc-number">1.2.</span> <span class="toc-text">exercise-2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exercise-3"><span class="toc-number">1.3.</span> <span class="toc-text">exercise-3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exercise-4"><span class="toc-number">1.4.</span> <span class="toc-text">exercise-4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exercise-5"><span class="toc-number">1.5.</span> <span class="toc-text">exercise-5</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/28/%E6%BA%90%E7%A0%81-ConcurrentHashMap/" title="无题">无题</a><time datetime="2023-08-28T13:30:56.850Z" title="发表于 2023-08-28 21:30:56">2023-08-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/25/spring-autowire/" title="自动装配">自动装配</a><time datetime="2023-07-25T14:22:05.000Z" title="发表于 2023-07-25 22:22:05">2023-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/24/MIT6-830-lab4/" title="lab4">lab4</a><time datetime="2023-07-24T01:15:54.000Z" title="发表于 2023-07-24 09:15:54">2023-07-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/24/MIT6-830-lab6/" title="lab6">lab6</a><time datetime="2023-07-24T01:15:54.000Z" title="发表于 2023-07-24 09:15:54">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/19/MIT6-830-lab2/" title="MIT6.830-Lab-2"><img src="/img/lab2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIT6.830-Lab-2"/></a><div class="content"><a class="title" href="/2023/07/19/MIT6-830-lab2/" title="MIT6.830-Lab-2">MIT6.830-Lab-2</a><time datetime="2023-07-19T02:29:23.000Z" title="发表于 2023-07-19 10:29:23">2023-07-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Jiang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function getGiscusTheme (theme) {
  return theme === 'dark' ? 'dark' : 'light'
}

function loadGiscus () {
  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'love-you-3000/giscus',
    'data-repo-id': 'R_kgDOJzFPYQ',
    'data-category-id': 'DIC_kwDOJzFPYc4CXas5',
    'data-mapping': 'pathname',
    'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },null)

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme (theme) {
  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame')
    if (!iframe) return
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
  }

  sendMessage({
    setConfig: {
      theme: getGiscusTheme(theme)
    }
  });
}

btf.addModeChange('giscus', changeGiscusTheme)

if ('Giscus' === 'Giscus' || !true) {
  if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script async src="/js/title.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b2dc59ff50b24673b677f4e13ad22962';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/06/22/welcome/" alt=""><img width="48" height="48" src="/img/welcome.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-22</span><a class="blog-slider__title" href="2023/06/22/welcome/" alt="">欢迎光临我的小破站</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2023/06/22/welcome/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>